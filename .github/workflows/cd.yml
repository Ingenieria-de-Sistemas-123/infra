name: CD (infra)

on:
  push:
    branches: [ dev, main ]

concurrency:
  group: cd-infra-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ github.ref_name == 'main' && secrets.VM_HOST_PROD || secrets.VM_HOST }}
          username: ${{ github.ref_name == 'main' && secrets.VM_USER_PROD || secrets.VM_USER }}
          key: ${{ github.ref_name == 'main' && secrets.DEPLOY_SSH_KEY_PROD || secrets.DEPLOY_SSH_KEY }}
          script_stop: true
          command_timeout: 20m
          script: |
            bash -s <<'EOF'
            set -Eeuo pipefail
            trap 'echo "::error::failed at line $LINENO"; exit 1' ERR
            set -x

            cd "${{ github.ref_name == 'main' && secrets.DEPLOY_WORKDIR_PROD || secrets.DEPLOY_WORKDIR}}"

            BRANCH='${{ github.ref_name }}'
            if [ "$BRANCH" = "main" ]; then COMPOSE_FILE="docker-compose.prod.yml"; ENV_FILE=".env.prod"; else COMPOSE_FILE="docker-compose.dev.yml"; ENV_FILE=".env.dev"; fi

            echo "[cd] sync infra repo to $BRANCH"
            git fetch --all --prune
            git reset --hard "origin/$BRANCH"

            echo "[cd] using compose file: $COMPOSE_FILE"
            test -f "$COMPOSE_FILE" || { echo "::error file=$COMPOSE_FILE::compose file not found"; exit 1; }

            echo "[cd] writing $ENV_FILE from secrets"
            : > "$ENV_FILE"

            VAR_SUFFIX=""
            if [ "$ENV_FILE" = ".env.prod" ]; then
              VAR_SUFFIX="_PROD"
            fi

            env_var() {
              local base="$1"
              if [ -n "$VAR_SUFFIX" ]; then
                printf '%s' "${base}${VAR_SUFFIX}"
              else
                printf '%s' "$base"
              fi
            }

            append_env() {
              echo "$1=$2" >> "$ENV_FILE"
            }

            # Permission DB
            append_env "$(env_var DB_PERMISSION_NAME)" "${{ secrets.DB_PERMISSION_NAME }}"
            append_env "$(env_var DB_PERMISSION_USER)" "${{ secrets.DB_PERMISSION_USER }}"
            append_env "$(env_var DB_PERMISSION_PASSWORD)" "${{ secrets.DB_PERMISSION_PASSWORD }}"
            append_env "$(env_var SPRING_DATASOURCE_URL_PERMISSIONDB)" "jdbc:postgresql://permission-db:5432/${{ secrets.DB_PERMISSION_NAME }}"
            append_env "$(env_var SPRING_DATASOURCE_USERNAME_PERMISSIONDB)" "${{ secrets.DB_PERMISSION_USER }}"
            append_env "$(env_var SPRING_DATASOURCE_PASSWORD_PERMISSIONDB)" "${{ secrets.DB_PERMISSION_PASSWORD }}"

            # Snippet DB
            append_env "$(env_var DB_SNIPPET_NAME)" "${{ secrets.DB_NAME }}"
            append_env "$(env_var DB_SNIPPET_USERNAME)" "${{ secrets.DB_USERNAME }}"
            append_env "$(env_var DB_SNIPPET_PASSWORD)" "${{ secrets.DB_PASSWORD }}"
            append_env "$(env_var SPRING_DATASOURCE_URL_SNIPPET)" "jdbc:postgresql://snippet-db:5432/${{ secrets.DB_NAME }}"
            append_env "$(env_var SPRING_DATASOURCE_USERNAME_SNIPPET)" "${{ secrets.DB_USERNAME }}"
            append_env "$(env_var SPRING_DATASOURCE_PASSWORD_SNIPPET)" "${{ secrets.DB_PASSWORD }}"

            # Auth0
            append_env "$(env_var SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI)" "${{ secrets.AUTH0_ISSUER }}"
            append_env "$(env_var AUTH0_AUDIENCE)" "${{ secrets.AUTH0_AUDIENCE }}"

            # Dev extras
            if [ "$ENV_FILE" = ".env.dev" ]; then
              append_env "SPRING_PROFILES_ACTIVE" "docker"
              append_env "LANGUAGE_BASE_URL" "http://language-service:8080"
            fi

            # Redis (obligatorio: secretos deben estar definidos)
            if [ -z "${{ secrets.REDIS_HOST }}" ]; then
              echo "::error::REDIS_HOST secret is required"
              exit 1
            fi
            append_env "$(env_var REDIS_HOST)" "${{ secrets.REDIS_HOST }}"

            if [ -z "${{ secrets.REDIS_PORT }}" ]; then
              echo "::error::REDIS_PORT secret is required"
              exit 1
            fi
            append_env "$(env_var REDIS_PORT)" "${{ secrets.REDIS_PORT }}"

            if [ -z "${{ secrets.SPRING_DATA_REDIS_HOST }}" ]; then
              echo "::error::SPRING_DATA_REDIS_HOST secret is required"
              exit 1
            fi
            append_env "$(env_var SPRING_DATA_REDIS_HOST)" "${{ secrets.SPRING_DATA_REDIS_HOST }}"

            if [ -z "${{ secrets.SPRING_DATA_REDIS_PORT }}" ]; then
              echo "::error::SPRING_DATA_REDIS_PORT secret is required"
              exit 1
            fi
            append_env "$(env_var SPRING_DATA_REDIS_PORT)" "${{ secrets.SPRING_DATA_REDIS_PORT }}"

            if [ -z "${{ secrets.SPRING_DATA_REDIS_URL }}" ]; then
              echo "::error::SPRING_DATA_REDIS_URL secret is required"
              exit 1
            fi
            append_env "$(env_var SPRING_DATA_REDIS_URL)" "${{ secrets.SPRING_DATA_REDIS_URL }}"

            # Asset service
            ASSET_SERVICE_BASE_URL="${{ secrets.ASSET_SERVICE_BASE_URL }}"
            if [ -z "$ASSET_SERVICE_BASE_URL" ]; then
              ASSET_SERVICE_BASE_URL="http://asset-service:8080"
            fi
            append_env "$(env_var ASSET_SERVICE_BASE_URL)" "$ASSET_SERVICE_BASE_URL"

            ASSET_SERVICE_AZURE_HOST="${{ secrets.ASSET_SERVICE_AZURE_HOST }}"
            if [ -z "$ASSET_SERVICE_AZURE_HOST" ]; then
              if [ "$ENV_FILE" = ".env.dev" ]; then
                ASSET_SERVICE_AZURE_HOST="http://azurite"
              else
                echo "::error::ASSET_SERVICE_AZURE_HOST secret is required for prod"
                exit 1
              fi
            fi
            append_env "$(env_var ASSET_SERVICE_AZURE_HOST)" "$ASSET_SERVICE_AZURE_HOST"

            append_env "$(env_var ASSET_SERVICE_NEW_RELIC_APP_NAME)" "${{ secrets.ASSET_SERVICE_NEW_RELIC_APP_NAME }}"
            append_env "$(env_var ASSET_SERVICE_NEW_RELIC_AGENT_ENABLED)" "${{ secrets.ASSET_SERVICE_NEW_RELIC_AGENT_ENABLED }}"

            # UI variables (se escriben en el env principal para simplificar)
            append_env "$(env_var VITE_AUTH0_DOMAIN)" "${{ secrets.VITE_AUTH0_DOMAIN }}"
            append_env "$(env_var VITE_AUTH0_CLIENT_ID)" "${{ secrets.VITE_AUTH0_CLIENT_ID }}"
            append_env "$(env_var VITE_AUTH0_AUDIENCE)" "${{ secrets.VITE_AUTH0_AUDIENCE }}"
            append_env "$(env_var VITE_AUTH0_CALLBACK_URL)" "${{ secrets.VITE_AUTH0_CALLBACK_URL }}"
            append_env "$(env_var VITE_PERMISSION_BASE_URL)" "${{ secrets.VITE_PERMISSION_BASE_URL }}"

            echo "[cd] login ghcr"
            docker logout ghcr.io >/dev/null 2>&1 || true
            echo "${{ secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ secrets.GHCR_USER || github.actor }}" --password-stdin

            if docker compose version >/dev/null 2>&1; then
              COMPOSE_BIN=(docker compose)
            elif command -v docker-compose >/dev/null 2>&1; then
              COMPOSE_BIN=(docker-compose)
            else
              echo "::error::Neither 'docker compose' nor 'docker-compose' is available"
              exit 1
            fi

            compose() {
              "${COMPOSE_BIN[@]}" "$@"
            }

            echo "[cd] pull images"
            compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" pull

            echo "[cd] config"
            compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" config

            compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" up -d --remove-orphans

            # Reemplazo: función de salud sin literales '...'
            wait_health() {
              local name="$1"
              echo "→ esperando salud: $name"
              for i in $(seq 1 40); do
                status="$(docker inspect -f '{{ .State.Health.Status }}' "$name" 2>/dev/null || echo starting)"
                if [ "$status" = "healthy" ]; then
                  echo "✓ $name healthy"
                  return 0
                fi
                sleep 2
              done
              echo "::error::$name no alcanzó estado healthy"
              return 1
            }

            wait_health permission-db
            wait_health snippet-db
            wait_health permission-service
            wait_health snippet-service
            wait_health language-service

            echo "[cd] state"
            compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" ps

            echo "[cd] prune images"
            docker image prune -f
            EOF
