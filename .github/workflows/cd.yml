name: CD (infra)

on:
  push:
    branches: [ dev, main ]

concurrency:
  group: cd-infra-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      DEPLOY_ENV: ${{ github.ref_name == 'main' && 'prod' || 'dev' }}
      DEPLOY_VM_HOST: ${{ github.ref_name == 'main' && secrets.VM_HOST_PROD || secrets.VM_HOST }}
      DEPLOY_VM_USER: ${{ github.ref_name == 'main' && secrets.VM_USER_PROD || secrets.VM_USER }}
      DEPLOY_SSH_KEY_MATERIAL: ${{ github.ref_name == 'main' && secrets.DEPLOY_SSH_KEY_PROD || secrets.DEPLOY_SSH_KEY }}
      DEPLOY_WORKDIR_PATH: ${{ github.ref_name == 'main' && secrets.DEPLOY_WORKDIR_PROD || secrets.DEPLOY_WORKDIR }}
      DUCKDNS_DOMAIN: ${{ github.ref_name == 'main' && 'snippet-org-prod.duckdns.org' || 'snippet-org-dev.duckdns.org' }}
    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ env.DEPLOY_VM_HOST }}
          username: ${{ env.DEPLOY_VM_USER }}
          key: ${{ env.DEPLOY_SSH_KEY_MATERIAL }}
          script_stop: false
          command_timeout: 20m
          script: |
            bash -s <<'EOF'
            set -Eeuo pipefail
            trap 'echo "::error::failed at line $LINENO"; exit 1' ERR

            cd "${{ env.DEPLOY_WORKDIR_PATH }}"

            BRANCH='${{ github.ref_name }}'
            if [ "$BRANCH" = "main" ]; then COMPOSE_FILE="docker-compose.prod.yml"; ENV_FILE=".env.prod"; PROJECT_NAME="infra-prod"; PROXY_SERVICE="reverse-proxy"; else COMPOSE_FILE="docker-compose.dev.yml"; ENV_FILE=".env.dev"; PROJECT_NAME="infra-dev"; PROXY_SERVICE="reverse-proxy-dev"; fi

            echo "[cd] duckdns domain: ${{ env.DUCKDNS_DOMAIN }}"

            echo "[cd] sync infra repo to $BRANCH"
            git fetch --all --prune
            git reset --hard "origin/$BRANCH"

            echo "[cd] using compose file: $COMPOSE_FILE"
            test -f "$COMPOSE_FILE" || { echo "::error file=$COMPOSE_FILE::compose file not found"; exit 1; }

            echo "[cd] writing $ENV_FILE from secrets"
            : > "$ENV_FILE"

            # Permission DB
            echo "DB_PERMISSION_NAME=${{ secrets.DB_PERMISSION_NAME }}" >> "$ENV_FILE"
            echo "DB_PERMISSION_USER=${{ secrets.DB_PERMISSION_USER }}" >> "$ENV_FILE"
            echo "DB_PERMISSION_PASSWORD=${{ secrets.DB_PERMISSION_PASSWORD }}" >> "$ENV_FILE"
            echo "SPRING_DATASOURCE_URL_PERMISSIONDB=jdbc:postgresql://permission-db:5432/${{ secrets.DB_PERMISSION_NAME }}" >> "$ENV_FILE"
            echo "SPRING_DATASOURCE_USERNAME_PERMISSIONDB=${{ secrets.DB_PERMISSION_USER }}" >> "$ENV_FILE"
            echo "SPRING_DATASOURCE_PASSWORD_PERMISSIONDB=${{ secrets.DB_PERMISSION_PASSWORD }}" >> "$ENV_FILE"

            # Snippet DB
            echo "DB_SNIPPET_NAME=${{ secrets.DB_NAME }}" >> "$ENV_FILE"
            echo "DB_SNIPPET_USERNAME=${{ secrets.DB_USERNAME }}" >> "$ENV_FILE"
            echo "DB_SNIPPET_PASSWORD=${{ secrets.DB_PASSWORD }}" >> "$ENV_FILE"
            echo "SPRING_DATASOURCE_URL_SNIPPET=jdbc:postgresql://snippet-db:5432/${{ secrets.DB_NAME }}" >> "$ENV_FILE"
            echo "SPRING_DATASOURCE_USERNAME_SNIPPET=${{ secrets.DB_USERNAME }}" >> "$ENV_FILE"
            echo "SPRING_DATASOURCE_PASSWORD_SNIPPET=${{ secrets.DB_PASSWORD }}" >> "$ENV_FILE"

            # Auth0
            echo "SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI=${{ secrets.AUTH0_ISSUER }}" >> "$ENV_FILE"
            echo "AUTH0_AUDIENCE=${{ secrets.AUTH0_AUDIENCE }}" >> "$ENV_FILE"

            # Shared defaults (dev/prod)
            echo "SPRING_PROFILES_ACTIVE=docker" >> "$ENV_FILE"
            echo "LANGUAGE_BASE_URL=http://language-service:8080" >> "$ENV_FILE"

            # New Relic
            NEW_RELIC_LICENSE_KEY="${{ secrets.NEW_RELIC_LICENSE_KEY }}"
            if [ -z "$NEW_RELIC_LICENSE_KEY" ]; then
              echo "::warning::NEW_RELIC_LICENSE_KEY secret is not set; New Relic will be disabled"
            else
              echo "NEW_RELIC_LICENSE_KEY=$NEW_RELIC_LICENSE_KEY" >> "$ENV_FILE"
            fi

            # Redis (obligatorio: secretos deben estar definidos)
            if [ -z "${{ secrets.REDIS_HOST }}" ]; then
              echo "::error::REDIS_HOST secret is required"
              exit 1
            fi
            echo "REDIS_HOST=${{ secrets.REDIS_HOST }}" >> "$ENV_FILE"

            if [ -z "${{ secrets.REDIS_PORT }}" ]; then
              echo "::error::REDIS_PORT secret is required"
              exit 1
            fi
            echo "REDIS_PORT=${{ secrets.REDIS_PORT }}" >> "$ENV_FILE"

            if [ -z "${{ secrets.SPRING_DATA_REDIS_HOST }}" ]; then
              echo "::error::SPRING_DATA_REDIS_HOST secret is required"
              exit 1
            fi
            echo "SPRING_DATA_REDIS_HOST=${{ secrets.SPRING_DATA_REDIS_HOST }}" >> "$ENV_FILE"

            if [ -z "${{ secrets.SPRING_DATA_REDIS_PORT }}" ]; then
              echo "::error::SPRING_DATA_REDIS_PORT secret is required"
              exit 1
            fi
            echo "SPRING_DATA_REDIS_PORT=${{ secrets.SPRING_DATA_REDIS_PORT }}" >> "$ENV_FILE"

            if [ -z "${{ secrets.SPRING_DATA_REDIS_URL }}" ]; then
              echo "::error::SPRING_DATA_REDIS_URL secret is required"
              exit 1
            fi
            echo "SPRING_DATA_REDIS_URL=${{ secrets.SPRING_DATA_REDIS_URL }}" >> "$ENV_FILE"

            # Asset service
            ASSET_SERVICE_BASE_URL="${{ secrets.ASSET_SERVICE_BASE_URL }}"
            if [ -z "$ASSET_SERVICE_BASE_URL" ]; then
              ASSET_SERVICE_BASE_URL="http://asset-service:8080"
            fi
            echo "ASSET_SERVICE_BASE_URL=${ASSET_SERVICE_BASE_URL}" >> "$ENV_FILE"

            ASSET_SERVICE_AZURE_HOST="${{ secrets.ASSET_SERVICE_AZURE_HOST }}"
            if [ -z "$ASSET_SERVICE_AZURE_HOST" ]; then
              if [ "$ENV_FILE" = ".env.dev" ]; then
                ASSET_SERVICE_AZURE_HOST="http://azurite"
              else
                echo "::error::ASSET_SERVICE_AZURE_HOST secret is required for prod"
                exit 1
              fi
            fi
            echo "ASSET_SERVICE_AZURE_HOST=${ASSET_SERVICE_AZURE_HOST}" >> "$ENV_FILE"

            echo "ASSET_SERVICE_NEW_RELIC_APP_NAME=${{ secrets.ASSET_SERVICE_NEW_RELIC_APP_NAME }}" >> "$ENV_FILE"
            echo "ASSET_SERVICE_NEW_RELIC_AGENT_ENABLED=${{ secrets.ASSET_SERVICE_NEW_RELIC_AGENT_ENABLED }}" >> "$ENV_FILE"

            # UI variables (prefer *_PROD on prod, fallback to shared secrets)
            VITE_AUTH0_DOMAIN="${{ github.ref_name == 'main' && secrets.VITE_AUTH0_DOMAIN_PROD || secrets.VITE_AUTH0_DOMAIN }}"
            VITE_AUTH0_CLIENT_ID="${{ github.ref_name == 'main' && secrets.VITE_AUTH0_CLIENT_ID_PROD || secrets.VITE_AUTH0_CLIENT_ID }}"
            VITE_AUTH0_AUDIENCE="${{ github.ref_name == 'main' && secrets.VITE_AUTH0_AUDIENCE_PROD || secrets.VITE_AUTH0_AUDIENCE }}"
            VITE_PERMISSION_BASE_URL="${{ github.ref_name == 'main' && secrets.VITE_PERMISSION_BASE_URL_PROD || secrets.VITE_PERMISSION_BASE_URL }}"

            if [ -z "$VITE_AUTH0_DOMAIN" ]; then
              echo "::error::VITE_AUTH0_DOMAIN (or VITE_AUTH0_DOMAIN_PROD) secret is required"
              exit 1
            fi
            if [ -z "$VITE_AUTH0_CLIENT_ID" ]; then
              echo "::error::VITE_AUTH0_CLIENT_ID (or VITE_AUTH0_CLIENT_ID_PROD) secret is required"
              exit 1
            fi
            if [ -z "$VITE_AUTH0_AUDIENCE" ]; then
              echo "::error::VITE_AUTH0_AUDIENCE (or VITE_AUTH0_AUDIENCE_PROD) secret is required"
              exit 1
            fi

            echo "VITE_AUTH0_DOMAIN=$VITE_AUTH0_DOMAIN" >> "$ENV_FILE"
            echo "VITE_AUTH0_CLIENT_ID=$VITE_AUTH0_CLIENT_ID" >> "$ENV_FILE"
            echo "VITE_AUTH0_AUDIENCE=$VITE_AUTH0_AUDIENCE" >> "$ENV_FILE"

            VITE_AUTH0_CALLBACK_URL=""
            VITE_BACKEND_URL=""
            if [ "$ENV_FILE" = ".env.prod" ]; then
              VITE_AUTH0_CALLBACK_URL="${{ secrets.VITE_AUTH0_CALLBACK_URL_PROD }}"
              VITE_BACKEND_URL="${{ secrets.VITE_BACKEND_URL_PROD }}"
            else
              VITE_AUTH0_CALLBACK_URL="${{ secrets.VITE_AUTH0_CALLBACK_URL }}"
              VITE_BACKEND_URL="${{ secrets.VITE_BACKEND_URL }}"
            fi

            if [ -z "$VITE_AUTH0_CALLBACK_URL" ]; then
              VITE_AUTH0_CALLBACK_URL="https://${{ env.DUCKDNS_DOMAIN }}/"
            fi
            if [ -z "$VITE_PERMISSION_BASE_URL" ]; then
              VITE_PERMISSION_BASE_URL="/api"
            fi
            if [ -z "$VITE_BACKEND_URL" ]; then
              VITE_BACKEND_URL="https://${{ env.DUCKDNS_DOMAIN }}/api"
            fi

            echo "VITE_AUTH0_CALLBACK_URL=$VITE_AUTH0_CALLBACK_URL" >> "$ENV_FILE"
            echo "VITE_PERMISSION_BASE_URL=$VITE_PERMISSION_BASE_URL" >> "$ENV_FILE"
            echo "VITE_BACKEND_URL=$VITE_BACKEND_URL" >> "$ENV_FILE"

            echo "[cd] login ghcr"
            docker logout ghcr.io >/dev/null 2>&1 || true
            echo "${{ secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ secrets.GHCR_USER || github.actor }}" --password-stdin

            if docker compose version >/dev/null 2>&1; then
              COMPOSE_BIN=(docker compose)
            elif command -v docker-compose >/dev/null 2>&1; then
              COMPOSE_BIN=(docker-compose)
            else
              echo "::error::Neither 'docker compose' nor 'docker-compose' is available"
              exit 1
            fi

            compose() {
              "${COMPOSE_BIN[@]}" -p "$PROJECT_NAME" "$@"
            }

            echo "[cd] pull images"
            compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" pull

            # New Relic Java agent (montado desde el host en ./newrelic -> /newrelic)
            NEW_RELIC_JAVA_TOOL_OPTIONS=""
            NR_DIR="newrelic"
            NR_JAR_FILE="${NR_DIR}/newrelic.jar"
            NR_CFG_FILE="${NR_DIR}/newrelic.yml"

            if [ -n "$NEW_RELIC_LICENSE_KEY" ]; then
              mkdir -p "$NR_DIR"

              if [ ! -f "$NR_JAR_FILE" ]; then
                echo "[cd] download New Relic Java agent"
                NR_ZIP_URL="https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip"
                tmp="$(mktemp -d)"
                zip_path="$tmp/newrelic-java.zip"

                if command -v curl >/dev/null 2>&1; then
                  curl -fsSL "$NR_ZIP_URL" -o "$zip_path" || true
                elif command -v wget >/dev/null 2>&1; then
                  wget -qO "$zip_path" "$NR_ZIP_URL" || true
                else
                  echo "::warning::curl/wget not available; cannot download New Relic agent automatically"
                fi

                if [ -f "$zip_path" ]; then
                  if command -v unzip >/dev/null 2>&1; then
                    unzip -q "$zip_path" -d "$tmp" || true
                  elif command -v python3 >/dev/null 2>&1; then
                    python3 -c 'import sys, zipfile; zipfile.ZipFile(sys.argv[1]).extractall(sys.argv[2])' "$zip_path" "$tmp" || true
                  else
                    echo "::warning::unzip/python3 not available; cannot extract New Relic agent zip"
                  fi

                  if [ -f "$tmp/newrelic/newrelic.jar" ]; then
                    cp "$tmp/newrelic/newrelic.jar" "$NR_JAR_FILE"
                  else
                    echo "::warning::New Relic zip extracted but newrelic/newrelic.jar not found"
                  fi
                fi

                rm -rf "$tmp" || true
              fi

              if [ ! -f "$NR_JAR_FILE" ]; then
                echo "[cd] fallback: download New Relic agent via docker"
                docker run --rm -v "$PWD/$NR_DIR":/out python:3-alpine \
                  python -c "import io,urllib.request,zipfile; data=urllib.request.urlopen('https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip').read(); z=zipfile.ZipFile(io.BytesIO(data)); open('/out/newrelic.jar','wb').write(z.read('newrelic/newrelic.jar'))" \
                  || true
              fi

              if [ ! -f "$NR_CFG_FILE" ]; then
                printf '%s\n' \
                  'common: &default_settings' \
                  '  distributed_tracing:' \
                  '    enabled: true' \
                  > "$NR_CFG_FILE"
              fi

              if [ -f "$NR_JAR_FILE" ]; then
                NEW_RELIC_JAVA_TOOL_OPTIONS="-javaagent:/newrelic/newrelic.jar"
              else
                echo "::warning::New Relic jar missing; running without -javaagent"
              fi
            fi

            echo "NEW_RELIC_JAVA_TOOL_OPTIONS=$NEW_RELIC_JAVA_TOOL_OPTIONS" >> "$ENV_FILE"

            echo "[cd] config"
            compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" config

            # Limpieza preventiva de contenedores residuales (evita conflictos de nombre)
            for service in printscript-ui reverse-proxy-dev snippet-service permission-service language-service; do
              docker rm -f "$service" 2>/dev/null || true
            done

            if ! compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" up -d --remove-orphans; then
              echo "::error::docker compose up failed"
              compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" ps || true
              compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" logs --no-color --timestamps --tail 200 snippet-service || true
              compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" logs --no-color --timestamps --tail 200 snippet-db || true
              compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" logs --no-color --timestamps --tail 200 redis || true
              compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" logs --no-color --timestamps --tail 200 permission-service || true
              compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" logs --no-color --timestamps --tail 200 permission-db || true
              compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" logs --no-color --timestamps --tail 200 language-service || true
              exit 1
            fi

            # Saltar health checks de Docker (pedido del usuario)
            echo "[cd] skipping docker health checks"

            echo "[cd] restart reverse-proxy (refresh upstream DNS)"
            compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" restart "$PROXY_SERVICE"

            # Esperar a que el contenedor de reverse-proxy esté en ejecución tras el restart
            echo "[cd] wait $PROXY_SERVICE running"
            for i in $(seq 1 30); do
              cid="$(compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" ps -q "$PROXY_SERVICE" || true)"
              if [ -n "$cid" ]; then
                running="$(docker inspect -f '{{.State.Running}}' "$cid" 2>/dev/null || echo false)"
                if [ "$running" = "true" ]; then
                  echo "✓ $PROXY_SERVICE running ($cid)"
                  break
                fi
              fi
              sleep 1
            done

            echo "[cd] verify reverse-proxy upstream connectivity"
            ok=false
            for i in $(seq 1 10); do
              if compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" exec -T "$PROXY_SERVICE" wget -qO- http://printscript-ui:80/ >/dev/null; then
                ok=true; break
              fi
              sleep 2
            done
            if [ "$ok" != true ]; then
              echo "::error::reverse-proxy cannot reach printscript-ui"
              compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" ps || true
              compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" logs --no-color --timestamps --tail 200 "$PROXY_SERVICE" || true
              compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" logs --no-color --timestamps --tail 200 printscript-ui || true
              exit 1
            fi

            # Reintentos para health vía reverse-proxy
            check_health_via_proxy() {
              local svc="$1"
              local url="http://$svc:8080/actuator/health"
              echo "→ $PROXY_SERVICE -> $url"
              for i in $(seq 1 10); do
                if compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" exec -T "$PROXY_SERVICE" sh -c "wget -qO- $url" | grep -q UP; then
                  echo "✓ $svc UP via $PROXY_SERVICE"
                  return 0
                fi
                sleep 2
              done
              echo "::error::$PROXY_SERVICE cannot reach $svc or health not UP"
              compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" logs --no-color --timestamps --tail 200 "$PROXY_SERVICE" || true
              compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" logs --no-color --timestamps --tail 200 "$svc" || true
              return 1
            }

            check_health_via_proxy snippet-service || exit 1
            check_health_via_proxy permission-service || exit 1
            check_health_via_proxy language-service || exit 1

            echo "[cd] verify UI assets are served (not HTML)"
            UI_HTML="$(compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" exec -T "$PROXY_SERVICE" sh -c 'wget -qO- http://printscript-ui:80/' || true)"
            CSS_PATH="$(printf "%s" "$UI_HTML" | grep -oE '/assets/[^"\x27]+\.css' | head -n1 || true)"
            JS_PATH="$(printf "%s" "$UI_HTML" | grep -oE '/assets/[^"\x27]+\.js' | head -n1 || true)"
            if [ -z "$CSS_PATH" ] || [ -z "$JS_PATH" ]; then
              echo "::error::could not detect UI asset paths in HTML"
              echo "$UI_HTML" | head -n 80 || true
              exit 1
            fi
            CSS_HEADERS="$(compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" exec -T "$PROXY_SERVICE" sh -c "wget -S -O /dev/null http://printscript-ui:80$CSS_PATH" 2>&1 || true)"
            JS_HEADERS="$(compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" exec -T "$PROXY_SERVICE" sh -c "wget -S -O /dev/null http://printscript-ui:80$JS_PATH" 2>&1 || true)"
            echo "$CSS_HEADERS" | grep -qiE 'Content-Type:.*text/css' || { echo "::error::UI CSS is not served as text/css"; echo "$CSS_HEADERS"; exit 1; }
            echo "$JS_HEADERS" | grep -qiE 'Content-Type:.*(application|text)/javascript' || { echo "::error::UI JS is not served as javascript"; echo "$JS_HEADERS"; exit 1; }

            echo "[cd] state"
            compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" ps

            echo "[cd] prune images"
            docker image prune -f
            EOF
