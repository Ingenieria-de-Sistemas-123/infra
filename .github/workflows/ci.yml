name: CI (infra)

on:
  push:
    branches: [ dev, main ]
  pull_request:
    branches: [ dev, main ]

jobs:
  compose-ci:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    env:
      COMPOSE_FILE: docker-compose.dev.yml
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Preparar archivo de entorno (.env.ci.dev) sin exponer secrets
        run: |
          set -euo pipefail
          file=".env.ci.dev"
          : > "$file"

          # Fallbacks locales (CI) si no hay Secrets (evitan warnings)
          DB_PERMISSION_NAME="${{ secrets.DB_PERMISSION_NAME }}"
          DB_PERMISSION_USER="${{ secrets.DB_PERMISSION_USER }}"
          DB_PERMISSION_PASSWORD="${{ secrets.DB_PERMISSION_PASSWORD }}"
          DB_SNIPPET_NAME="${{ secrets.DB_NAME }}"
          DB_SNIPPET_USERNAME="${{ secrets.DB_USERNAME }}"
          DB_SNIPPET_PASSWORD="${{ secrets.DB_PASSWORD }}"
          AUTH0_ISSUER="${{ secrets.AUTH0_ISSUER }}"
          AUTH0_AUDIENCE="${{ secrets.AUTH0_AUDIENCE }}"
          ASSET_SERVICE_AZURE_HOST="${{ secrets.ASSET_SERVICE_AZURE_HOST }}"
          ASSET_SERVICE_NEW_RELIC_APP_NAME="${{ secrets.ASSET_SERVICE_NEW_RELIC_APP_NAME }}"
          ASSET_SERVICE_NEW_RELIC_AGENT_ENABLED="${{ secrets.ASSET_SERVICE_NEW_RELIC_AGENT_ENABLED }}"
          ASSET_SERVICE_BASE_URL="${{ secrets.ASSET_SERVICE_BASE_URL }}"
          REDIS_HOST="${{ secrets.REDIS_HOST }}"
          REDIS_PORT="${{ secrets.REDIS_PORT }}"
          SPRING_DATA_REDIS_HOST="${{ secrets.SPRING_DATA_REDIS_HOST }}"
          SPRING_DATA_REDIS_PORT="${{ secrets.SPRING_DATA_REDIS_PORT }}"
          SPRING_DATA_REDIS_URL="${{ secrets.SPRING_DATA_REDIS_URL }}"
          VITE_AUTH0_DOMAIN="${{ secrets.VITE_AUTH0_DOMAIN }}"
          VITE_AUTH0_CLIENT_ID="${{ secrets.VITE_AUTH0_CLIENT_ID }}"
          VITE_AUTH0_AUDIENCE="${{ secrets.VITE_AUTH0_AUDIENCE }}"
          VITE_AUTH0_CALLBACK_URL="${{ secrets.VITE_AUTH0_CALLBACK_URL }}"
          VITE_PERMISSION_BASE_URL="${{ secrets.VITE_PERMISSION_BASE_URL }}"
          NEW_RELIC_LICENSE_KEY="${{ secrets.NEW_RELIC_LICENSE_KEY }}"

          # En CI deshabilitamos el javaagent (las imágenes dev no siempre incluyen el JAR)
          NEW_RELIC_JAVA_TOOL_OPTIONS=""

          if [ -z "$ASSET_SERVICE_BASE_URL" ]; then
            ASSET_SERVICE_BASE_URL="http://asset-service:8080"
          fi

          if [ -z "$REDIS_HOST" ]; then REDIS_HOST="redis"; fi
          if [ -z "$REDIS_PORT" ]; then REDIS_PORT="6379"; fi
          if [ -z "$SPRING_DATA_REDIS_HOST" ]; then SPRING_DATA_REDIS_HOST="redis"; fi
          if [ -z "$SPRING_DATA_REDIS_PORT" ]; then SPRING_DATA_REDIS_PORT="6379"; fi
          if [ -z "$SPRING_DATA_REDIS_URL" ]; then SPRING_DATA_REDIS_URL="redis://redis:6379"; fi

          {
            echo "DB_PERMISSION_NAME=${DB_PERMISSION_NAME}"
            echo "DB_PERMISSION_USER=${DB_PERMISSION_USER}"
            echo "DB_PERMISSION_PASSWORD=${DB_PERMISSION_PASSWORD}"
            echo "DB_SNIPPET_NAME=${DB_SNIPPET_NAME}"
            echo "DB_SNIPPET_USERNAME=${DB_SNIPPET_USERNAME}"
            echo "DB_SNIPPET_PASSWORD=${DB_SNIPPET_PASSWORD}"
            echo "SPRING_DATASOURCE_URL_PERMISSIONDB=jdbc:postgresql://permission-db:5432/${DB_PERMISSION_NAME}"
            echo "SPRING_DATASOURCE_USERNAME_PERMISSIONDB=${DB_PERMISSION_USER}"
            echo "SPRING_DATASOURCE_PASSWORD_PERMISSIONDB=${DB_PERMISSION_PASSWORD}"
            echo "SPRING_DATASOURCE_URL_SNIPPET=jdbc:postgresql://snippet-db:5432/${DB_SNIPPET_NAME}"
            echo "SPRING_DATASOURCE_USERNAME_SNIPPET=${DB_SNIPPET_USERNAME}"
            echo "SPRING_DATASOURCE_PASSWORD_SNIPPET=${DB_SNIPPET_PASSWORD}"
            echo "SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI=${AUTH0_ISSUER}"
            echo "AUTH0_AUDIENCE=${AUTH0_AUDIENCE}"
            echo "ASSET_SERVICE_BASE_URL=${ASSET_SERVICE_BASE_URL}"
            echo "ASSET_SERVICE_AZURE_HOST=${ASSET_SERVICE_AZURE_HOST}"
            echo "ASSET_SERVICE_NEW_RELIC_APP_NAME=${ASSET_SERVICE_NEW_RELIC_APP_NAME}"
            echo "ASSET_SERVICE_NEW_RELIC_AGENT_ENABLED=${ASSET_SERVICE_NEW_RELIC_AGENT_ENABLED}"
            echo "REDIS_HOST=${REDIS_HOST}"
            echo "REDIS_PORT=${REDIS_PORT}"
            echo "SPRING_DATA_REDIS_HOST=${SPRING_DATA_REDIS_HOST}"
            echo "SPRING_DATA_REDIS_PORT=${SPRING_DATA_REDIS_PORT}"
            echo "SPRING_DATA_REDIS_URL=${SPRING_DATA_REDIS_URL}"
            echo "VITE_AUTH0_DOMAIN=${VITE_AUTH0_DOMAIN}"
            echo "VITE_AUTH0_CLIENT_ID=${VITE_AUTH0_CLIENT_ID}"
            echo "VITE_AUTH0_AUDIENCE=${VITE_AUTH0_AUDIENCE}"
            echo "VITE_AUTH0_CALLBACK_URL=${VITE_AUTH0_CALLBACK_URL}"
            echo "VITE_PERMISSION_BASE_URL=${VITE_PERMISSION_BASE_URL}"
            echo "NEW_RELIC_LICENSE_KEY=${NEW_RELIC_LICENSE_KEY}"
            echo "NEW_RELIC_JAVA_TOOL_OPTIONS=${NEW_RELIC_JAVA_TOOL_OPTIONS}"
          } >> "$file"

          echo "Archivo .env.ci.dev generado."
          # docker-compose.dev.yml referencia env_file: .env.dev para printscript-ui
          cp .env.ci.dev .env.dev

      - name: Validar docker compose
        run: docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev config

      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_USER || github.actor }}
          password: ${{ secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Pull imágenes
        run: docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev pull

      - name: Levantar stack
        run: docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev up -d --remove-orphans

      - name: Esperar salud de contenedores (healthcheck vía Docker)
        run: |
          set -euo pipefail
          wait_health() {
            local name="$1"
            echo "→ esperando salud: $name"
            for i in $(seq 1 40); do
              status="$(docker inspect -f '{{ .State.Health.Status }}' "$name" 2>/dev/null || echo 'starting')"
              if [ "$status" = "healthy" ]; then
                echo "✓ $name healthy"
                return 0
              fi
              sleep 2
            done
            echo "::error::$name no alcanzó estado healthy"
            return 1
          }
          wait_health permission-db-dev
          wait_health permission-service-dev
          wait_health snippet-service-dev
          wait_health language-service-dev

      - name: Mostrar estado (sin secretos)
        run: docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev ps

      - name: Logs en fallo
        if: failure()
        run: |
          docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev logs --no-color --timestamps permission-db || true
          docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev logs --no-color --timestamps snippet-db || true
          docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev logs --no-color --timestamps permission-service || true
          docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev logs --no-color --timestamps snippet-service || true
          docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev logs --no-color --timestamps language-service || true
          docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev logs --no-color --timestamps asset-service || true
          docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev logs --no-color --timestamps reverse-proxy-dev || true
          docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev logs --no-color --timestamps printscript-ui || true
          docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev logs --no-color --timestamps azurite || true

      - name: Derribar stack
        if: always()
        run: docker compose -f "$COMPOSE_FILE" --env-file .env.ci.dev down -v

      - name: Borrar archivo temporal .env.ci.dev
        if: always()
        run: rm -f .env.ci.dev
      
      - name: Borrar archivo temporal .env.dev
        if: always()
        run: rm -f .env.dev
